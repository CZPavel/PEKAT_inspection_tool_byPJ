# ============================================================
#  UNIVERZÁLNÍ AI EDGE-TRIGGER PRO PEKAT VISION (Code modul)
#  - Režimy spouštění:
#       * "on_classes"  … vyhodnocení podle nalezených tříd (detector/classifier)
#       * "on_result"   … vyhodnocení podle context['result'] (OK=True, NG=False)
#  - Stavový automat: IDLE -> DEBOUNCE -> CAPTURE -> WAIT_RESET
#  - Debounce (ustálení po náběžné hraně) = LOOP_NUMBER snímků
#  - Capture (sběr/uložení/analýza)       = FRAME_NUMBER snímků
#  - Podpora více zdrojů: CLASSIFIER, DETECTOR
#  - Klasifikátor: volitelně brát jen top-1 (první z classNames = „celkový stav“)
#  - Kolize allowed & reset v jednom snímku: konfigurovatelná preference
#
#  JAK NASTAVIT Z OPERATOR VIEW:
#  --------------------------------
#  Vlož do Operator View prvky (Input/Select/Slider) a nastav jim Target Key:
#
#    trigger_mode            -> "on_classes" | "on_result"
#    allowed_classes         -> CSV nebo list (např. "POZICE_OK")
#    reset_classes           -> CSV nebo list (např. "OUT")
#    loop_number             -> int (např. 3)
#    frame_number            -> int (např. 5)
#    sources                 -> CSV/list z {"CLASSIFIER","DETECTOR"}, např. "CLASSIFIER,DETECTOR"
#    classifier_use_top_only -> bool (True/False) … u klasifikátoru jen první třída = top-1
#    conflict_preference     -> "allowed" | "reset" … co má přednost při kolizi
#    verbose                 -> bool … zapne ladicí výpisy do konzole
#
#  NENAJDE-LI se klíč v operatorInput, použijí se defaulty níže.
# ============================================================

import __main__
from typing import List, Set, Tuple

# ==========================
# 1) DEFAULTNÍ NASTAVENÍ
# ==========================
ALLOWED_CLASSES_DEFAULT: List[str] = ["POZICE"]   # spouštěcí třídy v režimu "on_classes"
RESET_CLASSES_DEFAULT:   List[str] = ["OUT"]         # reset třídy v režimu "on_classes"
LOOP_NUMBER_DEFAULT:     int = 5                     # DEBOUNCE: kolik snímků po náběžné hraně vyčkat
FRAME_NUMBER_DEFAULT:    int = 1                     # CAPTURE: kolik snímků zpracovat/uložit
VERBOSE_DEFAULT:         bool = True                 # ladicí výpisy do konzole

# Zdroje, které lze zvažovat v "on_classes"
SOURCE_CLASSIFIER = "CLASSIFIER"  # klasifikátor – vrací všechny třídy, top-1 je „celkový stav“
SOURCE_DETECTOR   = "DETECTOR"    # detektor     – může vracet víc tříd/obdélníků
SOURCES_DEFAULT: List[str] = [SOURCE_CLASSIFIER, SOURCE_DETECTOR]

CLASSIFIER_TOP_ONLY_DEF: bool = True    # True = brát jen první (top-1) třídu klasifikátoru
CONFLICT_PREF_DEFAULT:   str  = "reset" # "allowed"=spouštěcí má přednost; "reset"=reset má přednost

# ==========================
# 2) STAVOVÝ AUTOMAT
# ==========================
STATE_IDLE       = "IDLE"        # čekáme na náběžnou hranu (allowed z False->True)
STATE_DEBOUNCE   = "DEBOUNCE"    # ustalujeme allowed; musí držet LOOP_NUMBER snímků
STATE_CAPTURE    = "CAPTURE"     # sbíráme FRAME_NUMBER snímků
STATE_WAIT_RESET = "WAIT_RESET"  # čekáme na reset (RESET classes / result=False) nebo vymizení allowed

# ==========================
# 3) POMOCNÉ PARSERY (UI)
# ==========================
def _parse_bool(val, default: bool) -> bool:
    if isinstance(val, bool):
        return val
    if isinstance(val, str):
        s = val.strip().lower()
        if s in ("1", "true", "yes", "on"):  return True
        if s in ("0", "false", "no", "off"): return False
    return default

def _to_list(val, default_list: List[str]) -> List[str]:
    # Podporuje: None, list, CSV string
    if val is None:
        return default_list
    if isinstance(val, list):
        return [str(x).strip() for x in val]
    if isinstance(val, str):
        return [x.strip() for x in val.split(",") if x.strip()]
    return default_list

def _get_params(context):
    """
    Načte nastavení z context['operatorInput'] s fallbackem na defaulty.
    Klíče viz úvodní komentář.
    """
    oi = context.get('operatorInput', {}) or {}

    trigger_mode = str(oi.get("trigger_mode", "on_classes")).strip().lower()
    if trigger_mode not in ("on_classes", "on_result"):
        trigger_mode = "on_classes"

    allowed_classes = _to_list(oi.get("allowed_classes", None), ALLOWED_CLASSES_DEFAULT)
    reset_classes   = _to_list(oi.get("reset_classes", None),   RESET_CLASSES_DEFAULT)

    try:
        loop_number  = int(oi.get("loop_number", LOOP_NUMBER_DEFAULT))
    except: loop_number = LOOP_NUMBER_DEFAULT
    try:
        frame_number = int(oi.get("frame_number", FRAME_NUMBER_DEFAULT))
    except: frame_number = FRAME_NUMBER_DEFAULT

    verbose = _parse_bool(oi.get("verbose", None), VERBOSE_DEFAULT)

    sources = _to_list(oi.get("sources", None), SOURCES_DEFAULT)
    sources = [s.upper() for s in sources if s] or SOURCES_DEFAULT

    classifier_use_top_only = _parse_bool(
        oi.get("classifier_use_top_only", None),
        CLASSIFIER_TOP_ONLY_DEF
    )

    conflict_preference = str(oi.get("conflict_preference", CONFLICT_PREF_DEFAULT)).strip().lower()
    if conflict_preference not in ("allowed", "reset"):
        conflict_preference = CONFLICT_PREF_DEFAULT

    return {
        "trigger_mode": trigger_mode,
        "ALLOWED_CLASSES": allowed_classes,
        "RESET_CLASSES": reset_classes,
        "LOOP_NUMBER": loop_number,
        "FRAME_NUMBER": frame_number,
        "VERBOSE": verbose,
        "sources": sources,
        "classifier_use_top_only": classifier_use_top_only,
        "conflict_preference": conflict_preference,
    }

# ==========================
# 4) GLOBÁLNÍ PROMĚNNÉ (per projekt/instance)
# ==========================
def _init_globals():
    """Inicializace per-session stavů v __main__ (drží se mezi snímky)."""
    if 'AI_TRIG_STATE' not in dir(__main__):
        __main__.AI_TRIG_STATE = STATE_IDLE
    if 'AI_TRIG_DEB_CNT' not in dir(__main__):
        __main__.AI_TRIG_DEB_CNT = 0
    if 'AI_TRIG_CAP_CNT' not in dir(__main__):
        __main__.AI_TRIG_CAP_CNT = 0
    if 'AI_TRIG_PREV_ALLOWED' not in dir(__main__):
        __main__.AI_TRIG_PREV_ALLOWED = False
    if 'AI_TRIG_LAST_LABELS' not in dir(__main__):
        __main__.AI_TRIG_LAST_LABELS = set()

def _reset_all_to_idle():
    __main__.AI_TRIG_STATE = STATE_IDLE
    __main__.AI_TRIG_DEB_CNT = 0
    __main__.AI_TRIG_CAP_CNT = 0
    __main__.AI_TRIG_PREV_ALLOWED = False

def _set_wait_reset():
    __main__.AI_TRIG_STATE = STATE_WAIT_RESET
    __main__.AI_TRIG_DEB_CNT = 0
    __main__.AI_TRIG_CAP_CNT = 0

# ==========================
# 5) SBĚR TŘÍD Z CONTEXTU
# ==========================
def _collect_labels(context, sources: List[str], classifier_use_top_only: bool) -> Set[str]:
    """
    Vrátí množinu labelů z aktuálního snímku dle vybraných zdrojů.
    - CLASSIFIER:
        * classifier_use_top_only=True  -> jen první (top-1) třída z classNames
        * classifier_use_top_only=False -> zahrne všechny classNames + top-level label (fallback)
      POZN: Klasifikátor v PEKATu vrací všechny svoje třídy v pořadí dle skóre.
            První je „celkový stav snímku“ – typicky to, co chceme pro rozhodování.
    - DETECTOR:
        * zahrne top-level label (pokud je) a všechny položky z classNames
    """
    labels: Set[str] = set()
    detections = context.get('detectedRectangles', []) or []

    for d in detections:
        src_type = (d.get('source', {}) or {}).get('type', '').upper()

        # --- CLASSIFIER ---
        if SOURCE_CLASSIFIER in sources and src_type == SOURCE_CLASSIFIER:
            class_names = d.get('classNames', []) or []
            if classifier_use_top_only:
                # jen top-1
                if class_names:
                    lab = class_names[0].get('label')
                    if isinstance(lab, str) and lab:
                        labels.add(lab)
                else:
                    # fallback na top-level (některé verze mohou mít d['label'] / d['className'])
                    top = d.get('label') or d.get('className')
                    if isinstance(top, str) and top:
                        labels.add(top)
            else:
                # všechny třídy
                for cn in class_names:
                    lab = cn.get('label')
                    if isinstance(lab, str) and lab:
                        labels.add(lab)
                top = d.get('label') or d.get('className')
                if isinstance(top, str) and top:
                    labels.add(top)

        # --- DETECTOR ---
        if SOURCE_DETECTOR in sources and src_type == SOURCE_DETECTOR:
            top = d.get('label') or d.get('className')
            if isinstance(top, str) and top:
                labels.add(top)
            for cn in d.get('classNames', []) or []:
                lab = cn.get('label')
                if isinstance(lab, str) and lab:
                    labels.add(lab)

    return labels

# ==========================
# 6) KOLIZNÍ POLITIKA
# ==========================
def _apply_conflict_policy(allowed_found: bool, reset_found: bool, preference: str) -> Tuple[bool, bool]:
    """
    Pokud jsou ve stejném snímku současně spouštěcí i resetovací třída:
      - preference == "allowed" -> allowed=True, reset=False
      - preference == "reset"   -> allowed=False, reset=True
    Jinak vrací původní dvojici.
    """
    if allowed_found and reset_found:
        if preference == "allowed":
            return True, False
        else:
            return False, True
    return allowed_found, reset_found

# ==========================
# 7) HLAVNÍ FUNKCE
# ==========================
def main(context):
    """
    Univerzální edge-trigger s hysterezí (debounce) pro PEKAT Vision.
    - Nezadává žádné blokující čekání, vše je řízeno per-frame logikou a globálními čítači.
    - V DEBOUNCE/CAPTURE/WAIT_RESET typicky nastavuje context['exit']=True
      (zrychlí běh – nespouští zbytečně další moduly v aktuálním snímku).
    - Režim "on_result": allowed = (context['result'] is True), reset = (False) → preferujeme reset při result=False.
    - Režim "on_classes": allowed/reset dle tříd + kolizní preference.
    """
    _init_globals()
    P = _get_params(context)

    # 1) Zjisti allowed/reset podle zvoleného režimu
    if P["trigger_mode"] == "on_result":
        # Celkové vyhodnocení: OK=True => allowed; NG=False => reset
        res = bool(context.get('result', False))
        allowed_eff = res
        reset_eff   = (not res)
        labels_set  = set()  # jen pro debug
    else:
        # "on_classes": posbíráme labely ze zvolených zdrojů
        labels_set = _collect_labels(context, P["sources"], P["classifier_use_top_only"])
        allowed = any(l in P["ALLOWED_CLASSES"] for l in labels_set)
        reset   = any(l in P["RESET_CLASSES"]   for l in labels_set)
        allowed_eff, reset_eff = _apply_conflict_policy(allowed, reset, P["conflict_preference"])

    __main__.AI_TRIG_LAST_LABELS = labels_set  # pro přehled v debug/inspekci

    # 2) Detekce náběžné hrany allowed (False -> True)
    rising_edge = (not __main__.AI_TRIG_PREV_ALLOWED) and bool(allowed_eff)
    __main__.AI_TRIG_PREV_ALLOWED = bool(allowed_eff)

    # 3) Debug výpisy
    if P["VERBOSE"]:
        print(
            f"[AI-TRIG] mode={P['trigger_mode']} | state={__main__.AI_TRIG_STATE} "
            f"| allowed={allowed_eff} | reset={reset_eff} | edge={rising_edge} "
            f"| loop={P['LOOP_NUMBER']} | frames={P['FRAME_NUMBER']} "
            f"| sources={P['sources']} | topOnly={P['classifier_use_top_only']} "
            f"| conflict_pref={P['conflict_preference']} "
            f"| labels={sorted(list(labels_set)) if labels_set else '-'}"
        )

    # 4) RESET má prioritu (po aplikaci kolizní politiky)
    if reset_eff:
        if P["VERBOSE"]:
            print("[AI-TRIG] RESET -> IDLE")
        _reset_all_to_idle()
        context['exit'] = True
        return

    # 5) Stavový automat
    st = __main__.AI_TRIG_STATE

    if st == STATE_IDLE:
        # čekáme na náběžnou hranu allowed
        if rising_edge:
            __main__.AI_TRIG_STATE = STATE_DEBOUNCE
            __main__.AI_TRIG_DEB_CNT = 0
            if P["VERBOSE"]:
                print("[AI-TRIG] IDLE -> DEBOUNCE")
            context['exit'] = True
            return
        else:
            # nic – můžeme nechat doběhnout další moduly
            return

    elif st == STATE_DEBOUNCE:
        # allowed musí držet, jinak zpět do IDLE
        if not allowed_eff:
            if P["VERBOSE"]:
                print("[AI-TRIG] DEBOUNCE: allowed zmizel -> IDLE")
            _reset_all_to_idle()
            context['exit'] = True
            return

        __main__.AI_TRIG_DEB_CNT += 1
        if P["VERBOSE"]:
            print(f"[AI-TRIG] DEBOUNCE {__main__.AI_TRIG_DEB_CNT}/{P['LOOP_NUMBER']}")

        if __main__.AI_TRIG_DEB_CNT >= P["LOOP_NUMBER"]:
            __main__.AI_TRIG_STATE = STATE_CAPTURE
            __main__.AI_TRIG_CAP_CNT = 0
            if P["VERBOSE"]:
                print("[AI-TRIG] DEBOUNCE -> CAPTURE (ustáleno)")
        context['exit'] = True
        return

    elif st == STATE_CAPTURE:
        # pokud allowed během CAPTURE vymizí, přejdeme do WAIT_RESET
        if not allowed_eff:
            if P["VERBOSE"]:
                print("[AI-TRIG] CAPTURE: allowed zmizel -> WAIT_RESET")
            _set_wait_reset()
            context['exit'] = True
            return

        __main__.AI_TRIG_CAP_CNT += 1
        if P["VERBOSE"]:
            print(f"[AI-TRIG] CAPTURE {__main__.AI_TRIG_CAP_CNT}/{P['FRAME_NUMBER']}")

        # Zde můžeš dle potřeby dát „gate“ pro ukládání snímků:
        # context['capture_enabled'] = True

        if __main__.AI_TRIG_CAP_CNT >= P["FRAME_NUMBER"]:
            # volitelná indikace do Operator View:
            context['OK_result_visible']  = True
            context['NOK_result_visible'] = False
            if P["VERBOSE"]:
                print("[AI-TRIG] CAPTURE hotovo -> WAIT_RESET")
            _set_wait_reset()

        context['exit'] = True
        return

    elif st == STATE_WAIT_RESET:
        # čekáme, až allowed zmizí (nebo přijde reset_eff – to už řeší blok výše)
        if not allowed_eff:
            if P["VERBOSE"]:
                print("[AI-TRIG] WAIT_RESET: allowed pryč -> IDLE")
            _reset_all_to_idle()
            context['exit'] = True
            return

        # pořád čekáme; pro rychlost ukončíme aktuální větev
        context['exit'] = True
        return

    else:
        # fail-safe
        if P["VERBOSE"]:
            print(f"[AI-TRIG] Neznámý stav '{st}' -> IDLE (reset)")
        _reset_all_to_idle()
        context['exit'] = True
        return
